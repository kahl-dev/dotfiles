" Default settings {{{

let modules = 'find $DOTFILES/modules -type f -name "pre.vim" ! -name "_*.vim" | sort -n'
for fpath in split(system(modules), '\n')
  exe 'source' fpath
endfor

if &loadplugins
  if has('packages')

    " packadd! FastFold
    packadd! ale
    packadd! base16-vim
    packadd! delimitMate
    " packadd! editorconfig-vim
    packadd! gundo.vim
    packadd! indentLine
    " packadd! restore_view.vim
    packadd! tcomment_vim
    packadd! terminus
    packadd! vim-airline
    packadd! vim-airline-themes
    packadd! vim-devicons
    packadd! vim-easymotion
    packadd! vim-eunuch
    packadd! vim-fugitive
    packadd! vim-hardtime
    " packadd! vim-multiple-cursors
    packadd! vim-polyglot " language pack
    packadd! vim-rooter
    " packadd! vim-signify
    " packadd! vim-stay
    packadd! vim-surround
    packadd! vim-tmux-navigator
    " packadd! vim-trailing-whitespace
    " packadd! vim-unimpaired
    packadd! xml.vim
    packadd! vim-highlightedyank

  endif
endif


" Features {{{

filetype indent plugin on         " load filetype-specific indent files"
syntax on                         " Enable syntax highlighting

" }}}
" Must have options {{{

" One such option is the 'hidden' option, which allows you to re-use the same
" window and switch from an unsaved buffer without saving it first. Also allows
" you to keep an undo history for multiple files when re-using the same window
" in this way. Note that using persistent undo also lets you undo in multiple
" files even in the same window, but is less efficient and is actually designed
" for keeping undo history after closing Vim entirely. Vim will complain if you
" try to quit without saving, and swap files will keep you safe if your computer
" crashes.
set hidden

set encoding=utf-8                " set encoding to utf8
set wildmenu                      " better command-line completion
set wildmode=longest,list:full    " Auto-completion menu
set showcmd                       " show partial commands in last screen line
set hlsearch                      " highlight search
set splitbelow                    " on window split put below
set splitright                    " on window split put on right sote
set winwidth=110                  " force minimun window width

" }}}
" Usability options {{{

" Allow backspacing over autoindent, line breaks and start of insert action
set backspace=indent,eol,start

" Stop certain movements from always going to the first character of a line.
" While this behaviour deviates from that of Vi, it does what most users
" coming from other editors would expect.
set nostartofline

" Instead of failing a command because of unsaved changes, instead raise a
" dialogue asking if you wish to save changed files.
set confirm

" Quickly time out on keycodes, but never time out on mappings
set notimeout ttimeout ttimeoutlen=200

" Highlight 80 columns background
if exists('+colorcolumn')
  let &colorcolumn=join(range(81,999),",")" highlight column > 80
  highlight ColorColumn ctermbg=235 guibg=#2c2d27
  let &colorcolumn="80,".join(range(120,999),",")
endif

" Enable use of the mouse for all modes
if has('mouse_sgr')
  set ttymouse=sgr
endif
set mouse=a

" yank to clipboard
if has("clipboard")
  set clipboard=unnamed " copy to the system clipboard
  if has("unnamedplus") " X11 support
    set clipboard+=unnamedplus
  endif
endif

set lazyredraw                    " redraw only when we need to
set redrawtime=10000
set autoread                      " reload files changed outside vim
set incsearch                     " start search on type
set ignorecase                    " case insensitive search
set smartcase                     " insensitive search except using capital once
set autoindent                    " copy indent of current for new line
set ruler                         " show cursor on bottom
set laststatus=2                  " always display status line
set visualbell                    " visual bell instead of beeping
set t_vb=                         " reset terminal code for visual bell
set t_RV=                         " fix first line on load // bugfix for hyper
set number                        " show line numbers
set relativenumber                " show relative numbers
set nocursorcolumn
set nocursorline                    " highlight cursor line
set scrolloff=10                  " min numbers above and below cursor
set cmdheight=2                   " command window height to 2
set pastetoggle=<F10>             " toggle paste mode
autocmd VimResized * wincmd =     " Adjust vim size on resize

" augroup vimrc
"    autocmd!
"    autocmd BufWinEnter,Syntax * syn sync minlines=50 maxlines=50
"  augroup END
"  autocmd BufEnter * :syntax sync fromstart

" Auto check file changes
if ! exists("g:CheckUpdateStarted")
    let g:CheckUpdateStarted=1
    call timer_start(1,'CheckUpdate')
endif
function! CheckUpdate(timer)
    silent checktime
    call timer_start(50,'CheckUpdate')
endfunction


" }}}
" Undo/Backups {{{
" If a path ends in '//' then the swap file name is
" built from the entire path. No more issues between projects.

" Change swap directory.
if isdirectory($HOME . '/.vim/tmp/swap') == 0
    call mkdir($HOME . '/.vim/tmp/swap', 'p')
endif
set directory=~/.vim/tmp/swap//

" Change backup directory.
if isdirectory($HOME . '/.vim/tmp/backup') == 0
    call mkdir($HOME . '/.vim/tmp/backup', 'p')
endif
set backupdir=~/.vim/tmp/backup//

if exists('+undofile')
    " Change undo directory.
    if isdirectory($HOME . '/.vim/tmp/undo') == 0
        call mkdir($HOME . '/.vim/tmp/undo', 'p')
    endif
    set undodir=~/.vim/tmp/undo//
end

" Handle swap prompt

if has("autocmd")
    augroup AutoSwap
        autocmd!
        autocmd! SwapExists * call _HandleSwap(expand('<afile>:p'))
    augroup END
endif

function! _HandleSwap(filename)
    " If the swap file is old, delete. If it is new, recover.
    if getftime(v:swapname) < getftime(a:filename)
        let v:swapchoice = 'e'
        call _EchoSwapMessage("Deleted older swapfile.")
    else
        let v:swapchoice = 'r'
        call _EchoSwapMessage("Detected newer swapfile, recovering.")
    endif
endfunc

function! _EchoSwapMessage(message)
    if has("autocmd")
        augroup EchoSwapMessage
            autocmd!
            " Echo the message after entering a file, useful for
            " when we're entering a file (like on SwapExists)
            " and our echo will be eaten.
            autocmd BufWinEnter * echohl WarningMsg
            exec 'autocmd BufWinEnter * echon "\r'.printf("%-60s", a:message).'"'
            autocmd BufWinEnter * echohl NONE

            " Remove these auto commands so that they don't run on entering the next buffer.
            autocmd BufWinEnter * augroup EchoSwapMessage
            autocmd BufWinEnter * autocmd!
            autocmd BufWinEnter * augroup END
        augroup END
    endif
endfunction
" }}}
" Indentation options {{{

set tabstop=2                     " number of visual spaces per TAB
set shiftwidth=2                  " number of space characters inserted for indentation
set softtabstop=2                 " number of spaces in tab when editing
set expandtab                     " tabs are spaces


" }}}
" Mappings {{{

" ~/.vimrc
" Make Vim recognize XTerm escape sequences for Page and Arrow
" keys combined with modifiers such as Shift, Control, and Alt.
" See http://www.reddit.com/r/vim/comments/1a29vk/_/c8tze8p
if &term =~ '^screen'
  " Page keys http://sourceforge.net/p/tmux/tmux-code/ci/master/tree/FAQ
  execute "set t_kP=\e[5;*~"
  execute "set t_kN=\e[6;*~"

  " Arrow keys http://unix.stackexchange.com/a/34723
  execute "set <xUp>=\e[1;*A"
  execute "set <xDown>=\e[1;*B"
  execute "set <xRight>=\e[1;*C"
  execute "set <xLeft>=\e[1;*D"
endif

" http://vimcasts.org/episodes/bubbling-text/
" Bubble single lines
nmap <C-Up> [e
nmap <C-Down> ]e
" Bubble multiple lines
vmap <C-Up> [egv
vmap <C-Down> ]egv

" Disable arrow keys - muscle memory hjkl
noremap <Up> <NOP>
noremap <Down> <NOP>
noremap <Left> <NOP>
noremap <Right> <NOP>

" move vertically by visual line
nnoremap <expr> j v:count ? (v:count > 5 ? "m'" . v:count : '') . 'j' : 'gj'
nnoremap <expr> k v:count ? (v:count > 5 ? "m'" . v:count : '') . 'k' : 'gk'

" jk | Escaping!
inoremap jk <Esc>
xnoremap jk <Esc>
cnoremap jk <C-c>

command! W :w

nnoremap <CR> :nohlsearch<cr>

" vims . repeat with visual mode
xnoremap . :norm.<CR>

" highlight last inserted text
nnoremap gV `[v`]

" set leader key
let mapleader=","

" edit vimrc/zshrc and jload vimrc bindings
nnoremap <leader>ve :vsp $MYVIMRC<CR>
nnoremap <leader>vs :source $MYVIMRC<CR>

nnoremap <C-n> :bn<CR>
nnoremap <C-p> :bp<CR>

nnoremap <leader>y :call system('nc localhost 8377', @0)<CR>

nnoremap <C-s> :syntax sync fromstart<CR>

" Do not replace buffer with paste
xnoremap p "_dP

" play a macro recorded to register q
:nnoremap <Space> @q

let g:gundo_prefer_python3 = 1
nnoremap <F5> :GundoToggle<CR>

" }}}
" }}}
" {{{ Check python version if available
if has("python")
    python import vim; from sys import version_info as v; vim.command('let python_version=%d' % (v[0] * 100 + v[1]))
else
    let python_version=0
endif
" }}}

let modules = 'find $DOTFILES/modules -type f -name "*.vim" ! -name "pre.vim" ! -name "_*.vim" | sort -n'
for fpath in split(system(modules), '\n')
  exe 'source' fpath
endfor
