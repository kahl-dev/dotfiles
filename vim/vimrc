" Default settings {{{

" Install plug if not exists
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
    \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif

call plug#begin('~/.vim/plugged')

  let modules = 'find $DOTFILES/modules -type f -name "pre.vim" ! -name "_*.vim" | sort -n'
  for fpath in split(system(modules), '\n')
    exe 'source' fpath
  endfor

  " Terminus enhances Vim's and Neovim's integration with the terminal in
  " four ways, particularly when using tmux and iTerm or KDE Konsole,
  " closing the gap between terminal and GUI Vim
  " Doc: https://github.com/wincent/terminus
  Plug 'wincent/terminus'

  " Add icons to your plugins
  " Doc: https://github.com/ryanoasis/vim-devicons
  Plug 'ryanoasis/vim-devicons'

  " Surround.vim is all about "surroundings": parentheses, brackets, quotes,
  " XML tags, and more. The plugin provides mappings to easily delete, change
  " and add such surroundings in pairs.
  " Doc: https://github.com/tpope/vim-surround
  Plug 'tpope/vim-surround'

  " Vim sugar for the UNIX shell commands that need it the most
  " Doc: https://github.com/tpope/vim-eunuch
  Plug 'tpope/vim-eunuch'

  " Add repeat possibly for plugins like (souround ...)
  " Doc: https://github.com/tpope/vim-repeat
  Plug 'tpope/vim-repeat'

  " Syntax highlighting for CJSON in Vim
  " Doc: https://github.com/neoclide/jsonc.vim
  Plug 'neoclide/jsonc.vim'

" Features {{{

filetype indent plugin on         " load filetype-specific indent files
syntax on                         " Enable syntax highlighting

" }}}
" Must have options {{{

" One such option is the 'hidden' option, which allows you to re-use the same
" window and switch from an unsaved buffer without saving it first. Also allows
" you to keep an undo history for multiple files when re-using the same window
" in this way. Note that using persistent undo also lets you undo in multiple
" files even in the same window, but is less efficient and is actually designed
" for keeping undo history after closing Vim entirely. Vim will complain if you
" try to quit without saving, and swap files will keep you safe if your computer
" crashes.
" set hidden

set nohidden

set encoding=utf-8                " set encoding to utf8
set wildmenu                      " better command-line completion
set wildmode=longest,list:full    " Auto-completion menu
set showcmd                       " show partial commands in last screen line
set hlsearch                      " highlight search
set splitbelow                    " on window split put below
set splitright                    " on window split put on right sote
" set winwidth=110                  " force minimun window width
set term=xterm

" }}}
" Usability options {{{

" Allow backspacing over autoindent, line breaks and start of insert action
set backspace=indent,eol,start

" Stop certain movements from always going to the first character of a line.
" While this behaviour deviates from that of Vi, it does what most users
" coming from other editors would expect.
set nostartofline

" Instead of failing a command because of unsaved changes, instead raise a
" dialogue asking if you wish to save changed files.
set confirm

" Quickly time out on keycodes, but never time out on mappings
set notimeout ttimeout ttimeoutlen=200

" Always show the signcolumn, otherwise it would shift the text each time
" diagnostics appear/become resolved.
set signcolumn=yes


" Highlight 80 columns background
if exists('+colorcolumn')
  let &colorcolumn=join(range(81,999),",")" highlight column > 80
  highlight ColorColumn ctermbg=235 guibg=#2c2d27
  let &colorcolumn="80,".join(range(120,999),",")
endif

" Enable use of the mouse for all modes
if has('mouse_sgr')
  set ttymouse=sgr
endif
set mouse=a

" yank to clipboard
if has("clipboard")
  set clipboard=unnamed " copy to the system clipboard
  if has("unnamedplus") " X11 support
    set clipboard+=unnamedplus
  endif
endif

set lazyredraw                    " redraw only when we need to
set redrawtime=10000
set incsearch                     " start search on type
set ignorecase                    " case insensitive search
set smartcase                     " insensitive search except using capital once
set autoindent                    " copy indent of current for new line
set smartindent
set ruler                         " show cursor on bottom
set laststatus=2                  " always display status line
set visualbell                    " visual bell instead of beeping
set noerrorbells
set t_vb=                         " reset terminal code for visual bell
set t_RV=                         " fix first line on load // bugfix for hyper
set number                        " show line numbers
set relativenumber                " show relative numbers
set nocursorcolumn
set nocursorline                  " highlight cursor line
set scrolloff=10                  " min numbers above and below cursor
set cmdheight=2                   " command window height to 2
set pastetoggle=<F10>             " toggle paste mode
set nowrap                        " No line break
set updatetime=50
set conceallevel=2
autocmd VimResized * wincmd =     " Adjust vim size on resize

" Autoread will automatically update an open buffer if it has been changed
" outside the current edit session, usually by an external program.
" Blog: https://bluz71.github.io/2017/05/15/vim-tips-tricks.html#autoread
set autoread

augroup autoRead
    autocmd!
    autocmd CursorHold * silent! checktime
augroup END

" Computing syntax highlight information on the fly whilst scrolling can be
" slow in Vim
" Blog: https://bluz71.github.io/2017/05/15/vim-tips-tricks.html#improve-scroll-performance
augroup syntaxSyncMinLines
    autocmd!
    autocmd Syntax * syntax sync minlines=2000
augroup END

" }}}
" Undo/Backups {{{
" If a path ends in '//' then the swap file name is
" built from the entire path. No more issues between projects.

" https://gist.github.com/mllg/5353184
function Tmpwatch(path, days)
    let l:path = expand(a:path)
    if isdirectory(l:path)
        for file in split(globpath(l:path, "*"), "\n")
            if localtime() > getftime(file) + 86400 * a:days && delete(file) != 0
                echo "Tmpwatch(): Error deleting '" . file . "'"
            endif
        endfor
    else
        echo "Tmpwatch(): Directory '" . l:path . "' not found"
    endif
endfunction

" Change swap directory.
if isdirectory($HOME . '/.vim/tmp/swap') == 0
    call mkdir($HOME . '/.vim/tmp/swap', 'p')
endif
set directory=~/.vim/tmp/swap//
set noswapfile

" Change backup directory.
if isdirectory($HOME . '/.vim/tmp/backup') == 0
    call mkdir($HOME . '/.vim/tmp/backup', 'p')
endif
set backupdir=~/.vim/tmp/backup//
set nowritebackup
set nobackup

if exists('+undofile')
    " Change undo directory.
    if isdirectory($HOME . '/.vim/tmp/undo') == 0
        call mkdir($HOME . '/.vim/tmp/undo', 'p')
    endif
    set undodir=~/.vim/tmp/undo//
    set undofile
    set undolevels=1000
    set undoreload=10000

    " remove undo files which have not been modified for 31 days
    call Tmpwatch(&undodir, 31)
end


" Handle swap prompt
if has("autocmd")
    augroup AutoSwap
        autocmd!
        autocmd! SwapExists * call _HandleSwap(expand('<afile>:p'))
    augroup END
endif

function! _HandleSwap(filename)
    " If the swap file is old, delete. If it is new, recover.
    if getftime(v:swapname) < getftime(a:filename)
        let v:swapchoice = 'e'
        call _EchoSwapMessage("Deleted older swapfile.")
    else
        let v:swapchoice = 'r'
        call _EchoSwapMessage("Detected newer swapfile, recovering.")
    endif
endfunc

function! _EchoSwapMessage(message)
    if has("autocmd")
        augroup EchoSwapMessage
            autocmd!
            " Echo the message after entering a file, useful for
            " when we're entering a file (like on SwapExists)
            " and our echo will be eaten.
            autocmd BufWinEnter * echohl WarningMsg
            exec 'autocmd BufWinEnter * echon "\r'.printf("%-60s", a:message).'"'
            autocmd BufWinEnter * echohl NONE

            " Remove these auto commands so that they don't run on entering the next buffer.
            autocmd BufWinEnter * augroup EchoSwapMessage
            autocmd BufWinEnter * autocmd!
            autocmd BufWinEnter * augroup END
        augroup END
    endif
endfunction
" }}}
" Indentation options {{{

set tabstop=2                     " number of visual spaces per TAB
set shiftwidth=2                  " number of space characters inserted for indentation
set softtabstop=2                 " number of spaces in tab when editing
set expandtab                     " tabs are spaces


" }}}
" Mappings {{{

" Quit vim also with uppercase q
:command Q q

" ~/.vimrc
" Make Vim recognize XTerm escape sequences for Page and Arrow
" keys combined with modifiers such as Shift, Control, and Alt.
" See http://www.reddit.com/r/vim/comments/1a29vk/_/c8tze8p
if &term =~ '^screen'
  " Page keys http://sourceforge.net/p/tmux/tmux-code/ci/master/tree/FAQ
  execute "set t_kP=\e[5;*~"
  execute "set t_kN=\e[6;*~"

  " Arrow keys http://unix.stackexchange.com/a/34723
  execute "set <xUp>=\e[1;*A"
  execute "set <xDown>=\e[1;*B"
  execute "set <xRight>=\e[1;*C"
  execute "set <xLeft>=\e[1;*D"
endif

" http://vimcasts.org/episodes/bubbling-text/
" Bubble single lines
nmap <C-Up> [e
nmap <C-Down> ]e
" Bubble multiple lines
vmap <C-Up> [egv
vmap <C-Down> ]egv

" Disable arrow keys - muscle memory hjkl
noremap <Up> <NOP>
noremap <Down> <NOP>
noremap <Left> <NOP>
noremap <Right> <NOP>

" jk | Escaping!
inoremap jk <Esc>
xnoremap jk <Esc>
cnoremap jk <C-c>

command! W :w

nnoremap <CR> :nohlsearch<cr>

" Smarter j and k navigation
" Blog: https://bluz71.github.io/2017/05/15/vim-tips-tricks.html#smarter-j-and-k-navigation
nnoremap <expr> j v:count ? (v:count > 5 ? "m'" . v:count : '') . 'j' : 'gj'
nnoremap <expr> k v:count ? (v:count > 5 ? "m'" . v:count : '') . 'k' : 'gk'

" Make dot work over visual line selections
" Blog: https://bluz71.github.io/2017/05/15/vim-tips-tricks.html#make-dot-work-over-visual-line-selections
xnoremap . :norm.<CR>

" highlight last inserted text
nnoremap gV `[v`]

" set leader key
let mapleader=","

" edit vimrc/zshrc and jload vimrc bindings
nnoremap <leader>ve :vsp $MYVIMRC<CR>
nnoremap <leader>vs :source $MYVIMRC<CR>

nnoremap <C-n> :bn<CR>
nnoremap <C-p> :bp<CR>

nnoremap <C-s> :syntax sync fromstart<CR>

" Do not replace buffer with paste
xnoremap p "_dP

" Search and replace term cursor
nnoremap <Leader>s :%s/\<<C-r><C-w>\>/
nnoremap <Leader>S y:%s/<ctrl-r>"/new text/g

" }}}
" }}}
" {{{ Check python version if available
if has("python")
    python import vim; from sys import version_info as v; vim.command('let python_version=%d' % (v[0] * 100 + v[1]))
else
    let python_version=0
endif
" }}}

let localVimrc = "~/.vimrc-local"
if filereadable(expand(localVimrc))
  exe 'source' localVimrc
endif

let modules = 'find $DOTFILES/modules -type f -name "*.vim" ! -name "pre.vim" ! -name "_*.vim" | sort -n'
for fpath in split(system(modules), '\n')
  exe 'source' fpath
endfor

call plug#end()

if filereadable(expand("~/.vimrc_background"))
  let base16colorspace=256
  source ~/.vimrc_background
endif
